# -*- coding: utf-8 -*-
"""Perceptron I/O test make: Unsigned.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1MAn2Il7H4r8fe0r95AXMRpvpwO5CqpYj
"""

import pandas as pd
import numpy as np

#defining bias and input values
n_bits = int(8)
# n_bits_input= int(n_bits/2)
n_bits_input = n_bits
num_inputs = 4
bias = 110

2**n_bits/2

"""# Functions Calculus"""

import math
exp = math.exp

exp(2)

# x1= 1
# x2= 2
# x3= 3
# w1= 4
# w2= 5
# w3= -6
# sum = (x1*w1) + (x2*w2) + (x3*w3) + bias
# sum

# sum= -12

# tanh = 1-(exp(-2*sum))/(1+(exp(-2*sum)))
# tanh

def sigmoid (x):
  return (1/(1+(exp(-1*x))))
sigmoid(2)

function = sigmoid

"""# Começo"""

a = int(((2**n_bits)/2)-7) # 128 - 7 = 121
b = int(((2**n_bits)/2)+7) # 128 + 7 = 135

testes_x1 = range(0,14,1) #start, end, step
testes_x2 = range(0,14,1) #start, end, step
testes_x3 = range(0,14,1) #start, end, step
testes_w1 = range(0,14,1) #start, end, step
testes_w2 = range(0,14,1) #start, end, step
testes_w3 = range(0,14,1) #start, end, step

testes_x1

# testes_x1 = range(a,b,1) #start, end, step
# testes_x2 = (range(((2**n_bits)/2)-7,((2**n_bits)/2)+7,1)) #start, end, step
# testes_x3 = (range(((2**n_bits)/2)-7,((2**n_bits)/2)+7,1)) #start, end, step
# testes_w1 = (range(((2**n_bits)/2)-7,((2**n_bits)/2)+7,1)) #start, end, step
# testes_w2 = (range(((2**n_bits)/2)-7,((2**n_bits)/2)+7,1)) #start, end, step
# testes_w3 = (range(((2**n_bits)/2)-7,((2**n_bits)/2)+7,1)) #start, end, step

testes_x= []
testes_w= []
while True:
    if (i < 2):
      testes_x[i] = range(0,14,1) #start, end, step
      testes_w[i] = 1  #testes_wi
    else if(i < num_inputs)
      testes_x[i] = 1
      testes_w[i] = 1  #testes_wi

df_inputs = pd.DataFrame()
df_inputs['testes_x1'] = testes_x1
df_inputs['testes_x2'] = testes_x2
df_inputs['testes_x3'] = 5#testes_x3
df_inputs['testes_w1'] = 1  #testes_w1
df_inputs['testes_w2'] = 1  #testes_w2
df_inputs['testes_w3'] = 1  #testes_w3
df_inputs['bias'] = bias  #testes_w3

x1 = df_inputs['testes_x1']
x2 = df_inputs['testes_x2']
x3 = df_inputs['testes_x3']
w1 = df_inputs['testes_w1']
w2 = df_inputs['testes_w2']
w3 = df_inputs['testes_w3']


df_inputs['sum'] = (x1*w1) + (x2*w2) + (x3*w3) + bias

# df_inputs

df_inputs

# sigmoid_dx_list = np.linspace(-7,7,256) #vai de -7 a 7, dividido em 256 pontos (8 bits)
sigmoid_dx_list = np.linspace(-7,7,15) #vai de -128 a 127, dividido em 256 pontos (8 bits)
# sigmoid_dx_list= range(a,b+1,1)

sigmoid_dx_list

testes_x1

"""# df_sigmoid"""

df_sigmoid = pd.DataFrame((range(-7,8,1))) #start, end, step
df_sigmoid.columns = ['n'] # INPUTS_df
# df_sigmoid['dx'] = sigmoid_dx_list
df_sigmoid.head()

# df_sigmoid

sigmoid_dx_list

# ((1/(1+(exp(-1*(testes_x1))))).astype(float)).tolist()
# df[0].apply(lambda x: float(x))
multiplied_list = [(1/(1+(exp(-1*(element))))) for element in sigmoid_dx_list]
# multiplied_list
df_sigmoid['sigmoid']= multiplied_list
df_sigmoid.head()

unsigned_offset = 256

df_sigmoid['n'] = (df_sigmoid['n'] + (unsigned_offset/2)).astype(int)

df_sigmoid

# df_sigmoid[121:136]

import matplotlib.pyplot as plt
plt.close("all")

# (pd.Series(sigmoid_dx)).plot()
(pd.Series(multiplied_list)).plot()

# (pd.Series(multiplied_list[121:136])).plot()

#CONTAS Y(SAÍDA)
# df_sigmoid['sigmoid_dx']*df_sigmoid['n']

df_sigmoid['y']= (df_sigmoid['sigmoid']*df_sigmoid['n']) # y = sigmoid_dx * n

df_sigmoid['sig_int'] = df_sigmoid['sigmoid'].astype(int)
df_sigmoid['sig_norm']= df_sigmoid['sigmoid']*256
df_sigmoid['sig_norm_int'] = df_sigmoid['sig_norm'].astype(int)#8b ->MEMORY

df_sigmoid['y_norm_int']= (df_sigmoid['sig_norm_int']*df_sigmoid['n'])#16b
df_sigmoid['y_div']= (df_sigmoid['y_norm_int']/256)
df_sigmoid['y_int'] = df_sigmoid['y_div'].astype(int)
df_sigmoid

plt.plot( 'n', 'sig_int', data=df_sigmoid)

"""# df_sigmoid_bin"""

!pip install bitstring
from bitstring import BitArray

def int2bin(a,lenght):
  b= BitArray(int=a, lenght= lenght)
  return b.bin

#INT -> BINARY conversion (with 2 complement)
def int_to_bin(n, bits):
    s = bin(n & int("1"*bits, 2))[2:]
    return ("{0:0>%s}" % (bits)).format(s)

# #SIGMOID MEMORY
# df_sigmoid_bin = pd.DataFrame()

# #verification
# df_sigmoid_bin['address'] = (df_sigmoid['n'][121:136])
# df_sigmoid_bin['sig_norm_int_ver'] = (df_sigmoid['sig_norm_int'][121:136])

# df_sigmoid_bin['address_bin'] = (df_sigmoid['n'][121:136].apply(lambda x: int_to_bin(x ,n_bits)))
# df_sigmoid_bin['sig_norm_int'] = (df_sigmoid['sig_norm_int'][121:136].apply(lambda x: int_to_bin(x ,n_bits)))
# df_sigmoid_bin.head()

#SIGMOID MEMORY
df_sigmoid_bin = pd.DataFrame()

#verification
df_sigmoid_bin['address'] = (df_sigmoid['n'])
df_sigmoid_bin['sig_norm_int_ver'] = (df_sigmoid['sig_norm_int'])

df_sigmoid_bin['address_bin'] = (df_sigmoid['n'].apply(lambda x: int_to_bin(x ,n_bits)))
df_sigmoid_bin['sig_norm_int'] = (df_sigmoid['sig_norm_int'].apply(lambda x: int_to_bin(x ,n_bits)))
df_sigmoid_bin

len(df_sigmoid_bin)

"""# Graphs"""

import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

pacitydef = 0.8
# teste = go.Scatter(
#     # x=dftf.xs('Date', level='Stock info', axis=1)[tickers[k]],
#     x= dftf.index,
#     y=y_test,
#     name="teste",
#     line= dict(color='#0080FF'),
#     opacity = opacitydef,
#     line_shape='spline'
#     )

sigmoid = go.Scatter(
    # x=dftf.xs('Date', level='Stock info', axis=1)[tickers[k]],
    x= df_sigmoid_bin['address'],
    y=df_sigmoid_bin['sig_norm_int_ver'],
    name="sigmoid",
    line= dict(color='#FF8000'),
    opacity = opacitydef,
    line_shape='spline')

dadospred = ([sigmoid])#, pred])
figpred = go.Figure(data=dadospred)#, layout=layout)
py.iplot(figpred)

plt.plot( 'address', 'sig_norm_int_ver', data=df_sigmoid_bin, linestyle='-', marker='o')

df_sigmoid_bin

# https://matplotlib.org/3.3.4/api/_as_gen/matplotlib.pyplot.step.html
# plt.step('address', 'sig_norm_int_ver', where='post', data=df_sigmoid_bin, **kwargs)

plt.step('address', 'sig_norm_int_ver', where='post', data=df_sigmoid_bin, label='post')
plt.plot('address', 'sig_norm_int_ver', 'o--', color='grey', alpha=0.3)

# plt.grid(axis=df_sigmoid_bin['address'], color='0.95')
plt.legend(title='sigmoid memory')
# plt.title('plt.step(where=...)')

#https://stackoverflow.com/questions/35067304/pandas-dataframe-step-plot-where-post
df_sigmoid_bin.plot(drawstyle="steps", linewidth=2)
df_sigmoid_bin.plot(drawstyle="steps-post", linewidth=2)



"""# RAM/ROM bin -> .mif file"""

# https://www.google.com/url?sa=t&rct=j&q=&esrc=s&source=web&cd=&ved=2ahUKEwjO-qKlubruAhWNCrkGHSCwAmsQFjAAegQIARAC&url=https%3A%2F%2Fwww.mil.ufl.edu%2F4712%2Fdocs%2Fmif_help.pdf&usg=AOvVaw1fJCvah6C5OcARNOlKEIg4

memory_width=8
memory_depth = 256
memory_value_type = 'BIN' #Enter BIN, DEC, HEX, OCT, or UNS; #because memory is with (signed/unsigned) bin address

#https://stackoverflow.com/questions/19751148/quartus-initializing-ram
#https://stackoverflow.com/questions/10660435/pythonic-way-to-create-a-long-multi-line-string
rom_text_init = ('\n'
'DEPTH='+str(memory_depth)+';\n'
'WIDTH='+str(memory_width)+';\n'
'ADDRESS_RADIX='+(memory_value_type)+';\n' #because memory is with (signed/unsigned) bin address
'DATA_RADIX='+(memory_value_type)+';\n' #because data is bin type
'\n'
'CONTENT BEGIN\n'
'[0.. 01111000] : 00000000;\n' #value = 0
'[10001000.. 11111111] : 11111111;\n' #value = max(8bits) = 255

''+ df_sigmoid_bin['address_bin'][0] + ':'   +df_sigmoid_bin['sig_norm_int'][0]+  ';-- 121\n'
''+ df_sigmoid_bin['address_bin'][1] + ':'   +df_sigmoid_bin['sig_norm_int'][1]+  ';-- 122\n'   
''+ df_sigmoid_bin['address_bin'][2] + ':'   +df_sigmoid_bin['sig_norm_int'][2]+  ';-- 123\n'
''+ df_sigmoid_bin['address_bin'][3] + ':'   +df_sigmoid_bin['sig_norm_int'][3]+  ';-- 124\n'
''+ df_sigmoid_bin['address_bin'][4] + ':'   +df_sigmoid_bin['sig_norm_int'][4]+  ';-- 125\n'
''+ df_sigmoid_bin['address_bin'][5] + ':'   +df_sigmoid_bin['sig_norm_int'][5]+  ';-- 126\n'
''+ df_sigmoid_bin['address_bin'][6] + ':'   +df_sigmoid_bin['sig_norm_int'][6]+  ';-- 127\n'
''+ df_sigmoid_bin['address_bin'][7] + ':'   +df_sigmoid_bin['sig_norm_int'][7]+  ';-- 128\n'
''+ df_sigmoid_bin['address_bin'][8] + ':'   +df_sigmoid_bin['sig_norm_int'][8]+  ';-- 129\n'
''+ df_sigmoid_bin['address_bin'][9] + ':'   +df_sigmoid_bin['sig_norm_int'][9]+  ';-- 130\n'
''+ df_sigmoid_bin['address_bin'][10] + ':'  +df_sigmoid_bin['sig_norm_int'][10]+ ';-- 131\n'
''+ df_sigmoid_bin['address_bin'][11] + ':'  +df_sigmoid_bin['sig_norm_int'][11]+ ';-- 132\n'
''+ df_sigmoid_bin['address_bin'][12] + ':'  +df_sigmoid_bin['sig_norm_int'][12]+ ';-- 133\n'
''+ df_sigmoid_bin['address_bin'][13] + ':'  +df_sigmoid_bin['sig_norm_int'][13]+ ';-- 134\n'
''+ df_sigmoid_bin['address_bin'][14] + ':'  +df_sigmoid_bin['sig_norm_int'][14]+ ';-- 135\n'

#[40..7F]  :   0000000000000000;
'END;\n'
'')

rom_text_init

text_file = open("rom_text_init.txt", "w")
text_file.write(rom_text_init)
text_file.close()

len(df_sigmoid_bin)

i= 0;
for i in range(len(df_sigmoid_bin)):
   text = (''+ df_sigmoid_bin['address_bin'][i] + ':' +df_sigmoid_bin['sig_norm_int'][i]+  ';-- 120 + i\n')

#https://stackoverflow.com/questions/19751148/quartus-initializing-ram
#https://stackoverflow.com/questions/10660435/pythonic-way-to-create-a-long-multi-line-string
rom_text_init = ('\n'
'DEPTH='+str(memory_depth)+';\n'
'WIDTH='+str(memory_width)+';\n'
'ADDRESS_RADIX='+(memory_value_type)+';\n' #because memory is with (signed/unsigned) bin address
'DATA_RADIX='+(memory_value_type)+';\n' #because data is bin type
'\n'
'CONTENT BEGIN\n'
'[0.. 01111000] : 00000000;\n' #value = 0
'[10001000.. 11111111] : 11111111;\n' #value = max(8bits) = 255


''+text+''
#[40..7F]  :   0000000000000000;
'END;\n'
'')

# import binascii
# filename = 'test.dat'
# with open(filename, 'rb') as f:
#     content = f.read()
# print(binascii.hexlify(content))

# #https://stackoverflow.com/questions/10660435/pythonic-way-to-create-a-long-multi-line-string
# rom_text_file = (''
# 'WIDTH='+memory_width+';'
# 'DEPTH='+memory_depth+';'
# 'ADDRESS_RADIX='+memory_value_type+';' #because memory is with (signed/unsigned) bin address
# 'DATA_RADIX='+memory_value_type+';' #because data is bin type
# ''
# 'CONTENT BEGIN'
# '[0.. ('01111001 - 1)] : 00000000; #value = 0
# [(10000111 + 1).. (11111111)] : 11111111; #value = max(8bits) = 255

# 01111001  :   00000000;-- 121
# 01111010  :   00000000;-- 122    
# 01111011  :   00000001;-- 123
# 01111100  :   00000100;-- 124
# 01111101  :   00001100;-- 125
# 01111110  :   00011110;-- 126
# 01111111  :   01000100;-- 127
# 10000000  :   10000000;-- 128
# 10000001  :   10111011;-- 129
# 10000010  :   11100001;-- 130
# 10000011  :   11110011;-- 131
# 10000100  :   11111011;-- 132
# 10000101  :   11111110;-- 133
# 10000110  :   11111111;-- 134
# 10000111  :   11111111;-- 135

# #[40..7F]  :   0000000000000000;
# END;
# """)

text

"""# df_sum"""

# #SUM REFERENCE
# df_sum = pd.DataFrame()

# ## verification
# df_sum['sum_value'] = (df_sigmoid['n'][123:137])

# df_sum['n'] = (df_sigmoid['n'][123:137].apply(lambda x: int_to_bin(x ,n_bits)))
# # df_sum

#SUM REFERENCE
df_sum = pd.DataFrame()

## verification
df_sum['sum_value'] = (df_sigmoid['n'])

df_sum['n'] = (df_sigmoid['n'].apply(lambda x: int_to_bin(x ,n_bits)))
# df_sum

df_sigmoid

# df_inputs

"""# df_inputs_bin"""

# df_inputs.head()

# df_sigmoid

df_inputs['sigmoid']= [((1/(1+(exp(-1*((element-128))))))*256) for element in df_inputs['sum']]
df_inputs['sigmoid'] = df_inputs['sigmoid'].astype(int)
df_inputs['mult']=df_inputs['sum']*df_inputs['sigmoid']
df_inputs['mult'] = df_inputs['mult'].astype(int)

df_inputs['y'] = df_inputs['sum']/256 +(df_inputs['sum']*df_inputs['sigmoid'])/256
df_inputs['y'] = df_inputs['y'].astype(int)

df_inputs

df_inputs_bin = pd.DataFrame()
df_inputs_bin['x1'] = df_inputs['testes_x1'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['x2'] = df_inputs['testes_x2'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['x3'] = df_inputs['testes_x3'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['w1'] = df_inputs['testes_w1'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['w2'] = df_inputs['testes_w2'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['w3'] = df_inputs['testes_w3'].apply(lambda x: int_to_bin(x ,n_bits_input))
df_inputs_bin['bias'] = df_inputs['bias'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['sum'] = df_inputs['sum'].apply(lambda x: int_to_bin(x ,n_bits))
# n_bits_input
df_inputs_bin

# df_inputs_bin = pd.DataFrame()
# df_inputs_bin['x1'] = df_inputs['testes_x1'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['x2'] = df_inputs['testes_x2'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['x3'] = df_inputs['testes_x3'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['w1'] = df_inputs['testes_w1'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['w2'] = df_inputs['testes_w2'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['w3'] = df_inputs['testes_w3'].apply(lambda x: int_to_bin(x ,n_bits))
# df_inputs_bin['bias'] = df_inputs['bias'].apply(lambda x: int_to_bin(x ,n_bits))
# # df_inputs_bin['sum'] = df_inputs['sum'].apply(lambda x: int_to_bin(x ,n_bits))
# n_bits_input
# # df_inputs_bin.head()
# df_inputs_bin

"""# df_y_int_bin"""

# # OUTPUT REFERENCE
# df_y_int_bin = pd.DataFrame()

# ## verification
# df_y_int_bin['sum_value'] = (df_sigmoid['n'][123:137])
# df_y_int_bin['sum_value_bin'] = (df_sigmoid['n'][123:137].apply(lambda x: int_to_bin(x ,n_bits)))

# # df_sum['n'] = (df_sigmoid['n'][123:137].apply(lambda x: int_to_bin(x ,n_bits)))

# df_y_int_bin['y_int'] = (df_sigmoid['y_int'][123:137].apply(lambda x: int_to_bin(x ,n_bits)))
# df_y_int_bin

# df_sigmoid

# df_inputs

# OUTPUT REFERENCE
df_y_int_bin = pd.DataFrame()

## verification
df_y_int_bin['sum'] = (df_inputs['sum'])
df_y_int_bin['sum_bin'] = (df_inputs['sum'].apply(lambda x: int_to_bin(x ,n_bits)))

# df_sum['n'] = (df_sigmoid['n'][123:137].apply(lambda x: int_to_bin(x ,n_bits)))

df_y_int_bin['y'] = (df_inputs['y'])
df_y_int_bin['y_bin'] = (df_inputs['y'].apply(lambda x: int_to_bin(x ,n_bits)))
df_y_int_bin

# sig_sel = [(1/(1+(exp(-1*(element))))) for element in sigmoid_dx_list]

# df_sigmoid['y_int'][123:137]

# df_y_int_bin

# # plt.plot( 'n', 'sig_int', data=df_sigmoid[121:150])
# # plt.plot( 'n', 'sigmoid', data=df_sigmoid[121:150])
# # plt.plot( 'n', 'sig_int', data=df_sigmoid) #como será com 8 bits truncando
# # plt.plot( 'n', 'sig_norm_int', data=df_sigmoid) #8 bits * 256
# # plt.plot( 'n', 'sig_norm_int', data=df_sigmoid[121:136])
# # plt.plot( 'n', 'sig_norm_int', data=df_sigmoid)

# plt.plot( 'n', 'y', data=df_sigmoid[123:137])
# plt.plot( 'n', 'y_int', data=df_sigmoid[123:137])

# y_list = [(1/(1+(exp(-1*(element))))) for element in sigmoid_dx]

# if ((element in testes_x1 >= -6) or (element in testes_x1 <= 6))
#   y_list = []

# pd.DataFrame(np.linspace(-12,12,256))

"""# Gravando na Memória"""

import itertools

# DataFrames:
# Inputs: df_inputs_bin
# Sum_reference: df_sum
# Outputs : df_y_int_bin
# Sigmoid[-7:7]: df_sigmoid_bin

#INPUTS -> TEXT
# df_inputs_bin= df_inputs_bin.drop(['sum'],axis=1) #delete colum 'sum'
np.savetxt(r'c:\data\df_inputs_bin.txt', df_inputs_bin.values, fmt='%s')
# df.to_csv(r'c:\data\pandas.txt', header=None, index=None, sep=' ', mode='a')

df_inputs_bin

df_inputs

df_y_int_bin.head()

#OUTPUTS -> TEXT
df_y_int_bin= df_y_int_bin.drop(['sum'], axis=1) # tira coluna sum
df_y_int_bin= df_y_int_bin.drop(['sum_bin'], axis=1) # tira coluna sum_bin
df_y_int_bin= df_y_int_bin.drop(['y'], axis=1) # tira coluna y inteiro

np.savetxt(r'c:\data\df_y_int_bin.txt', df_y_int_bin.values, fmt='%s')
# df_y_int_bin

# df_y_int_bin.head()
# df_y_int_bin

df_sigmoid_bin.head()

df_sigmoid_bin= df_sigmoid_bin.drop(['address'], axis=1) # tira coluna sum
df_sigmoid_bin= df_sigmoid_bin.drop(['sig_norm_int_ver'], axis=1) # tira coluna sum

df_sigmoid_bin #ou tudo será signed ou tudo será unsigned

np.savetxt(r'c:\data\df_sigmoid_bin.txt', df_sigmoid_bin.values, fmt='%s')

# print(f'{bin_a} {bin_b}', file = input_f)

