# -*- coding: utf-8 -*-
"""Python_vhd_exponential.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YYSHReAH5Ni711zLf2vy41g7M7eWz5O6
"""

import pandas as pd
import numpy as np
# import

num_inputs = 40
bits_input = 8
bits = 8
sum_name = 'sum_python'

"""# Example"""

# memory_width=8
# memory_depth = 256
# memory_value_type = 'BIN' #Enter BIN, DEC, HEX, OCT, or UNS; #because memory is with (signed/unsigned) bin address

# #https://stackoverflow.com/questions/19751148/quartus-initializing-ram
# #https://stackoverflow.com/questions/10660435/pythonic-way-to-create-a-long-multi-line-string
# rom_text_init = ('\n'
# 'DEPTH='+str(memory_depth)+';\n'
# 'WIDTH='+str(memory_width)+';\n'
# 'ADDRESS_RADIX='+(memory_value_type)+';\n' #because memory is with (signed/unsigned) bin address
# 'DATA_RADIX='+(memory_value_type)+';\n' #because data is bin type
# '\n'
# 'CONTENT BEGIN\n'
# '[0.. 01111000] : 00000000;\n' #value = 0
# '[10001000.. 11111111] : 11111111;\n' #value = max(8bits) = 255

# ''+ df_sigmoid_bin['address_bin'][0] + ':'   +df_sigmoid_bin['sig_norm_int'][0]+  ';-- 121\n'
# ''+ df_sigmoid_bin['address_bin'][1] + ':'   +df_sigmoid_bin['sig_norm_int'][1]+  ';-- 122\n'   
# ''+ df_sigmoid_bin['address_bin'][2] + ':'   +df_sigmoid_bin['sig_norm_int'][2]+  ';-- 123\n'
# ''+ df_sigmoid_bin['address_bin'][3] + ':'   +df_sigmoid_bin['sig_norm_int'][3]+  ';-- 124\n'
# ''+ df_sigmoid_bin['address_bin'][4] + ':'   +df_sigmoid_bin['sig_norm_int'][4]+  ';-- 125\n'
# ''+ df_sigmoid_bin['address_bin'][5] + ':'   +df_sigmoid_bin['sig_norm_int'][5]+  ';-- 126\n'
# ''+ df_sigmoid_bin['address_bin'][6] + ':'   +df_sigmoid_bin['sig_norm_int'][6]+  ';-- 127\n'
# ''+ df_sigmoid_bin['address_bin'][7] + ':'   +df_sigmoid_bin['sig_norm_int'][7]+  ';-- 128\n'
# ''+ df_sigmoid_bin['address_bin'][8] + ':'   +df_sigmoid_bin['sig_norm_int'][8]+  ';-- 129\n'
# ''+ df_sigmoid_bin['address_bin'][9] + ':'   +df_sigmoid_bin['sig_norm_int'][9]+  ';-- 130\n'
# ''+ df_sigmoid_bin['address_bin'][10] + ':'  +df_sigmoid_bin['sig_norm_int'][10]+ ';-- 131\n'
# ''+ df_sigmoid_bin['address_bin'][11] + ':'  +df_sigmoid_bin['sig_norm_int'][11]+ ';-- 132\n'
# ''+ df_sigmoid_bin['address_bin'][12] + ':'  +df_sigmoid_bin['sig_norm_int'][12]+ ';-- 133\n'
# ''+ df_sigmoid_bin['address_bin'][13] + ':'  +df_sigmoid_bin['sig_norm_int'][13]+ ';-- 134\n'
# ''+ df_sigmoid_bin['address_bin'][14] + ':'  +df_sigmoid_bin['sig_norm_int'][14]+ ';-- 135\n'

# #[40..7F]  :   0000000000000000;
# 'END;\n'
# '')

"""# Sequences"""

#Xi Wi String Sequence
x_sequence = []
w_sequence = []
sx_sequence = []
sw_sequence = []
valx_sequence = []
valw_sequence = []
x_map_tb = []
w_map_tb = []
i=0

while True:
  if (i < num_inputs):
    x_sequence.append("x"+str(i+1)+",")
    w_sequence.append("w"+str(i+1)+",")
    sx_sequence.append("sx"+str(i+1)+",")
    sw_sequence.append("sw"+str(i+1)+",")  
    valx_sequence.append("val_x"+str(i+1)+",")
    valw_sequence.append("val_w"+str(i+1)+",")
    x_map_tb.append("x"+str(i+1)+"=>x"+str(i+1)+",")     
    w_map_tb.append("w"+str(i+1)+"=>w"+str(i+1)+",")     
    i= i+1
  else:
    x_w_sequence_string = ''.join(map(str, (x_sequence+w_sequence))) 
    x_sequence_string = ''.join(map(str, (x_sequence))) 
    w_sequence_string = ''.join(map(str, (w_sequence)))
    sx_sequence_string = ''.join(map(str, (sx_sequence))) 
    sw_sequence_string = ''.join(map(str, (sw_sequence))) 
    valx_sequence_string = ''.join(map(str, (valx_sequence))) 
    valw_sequence_string = ''.join(map(str, (valw_sequence))) 
    xw_map_tb_sequence_string = ''.join(map(str, (x_map_tb+w_map_tb))) 

    i= 0
    break

xw_map_tb_sequence_string[:-1]

valx_sequence_string

x_sequence_string

#INPUTS
#https://stackoverflow.com/questions/15478127/remove-final-character-from-string
i = 0
x = ""+x_sequence_string[:-1]+": in std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
w = ""+w_sequence_string[:-1]+": in std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
#SIGNALS
sx = "signal "+sx_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
sw = "signal "+sw_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"

sx_tb = "signal "+x_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
sw_tb = "signal "+w_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"

val_x = "signal "+valx_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
val_w = "signal "+valw_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"

val_x_tb = "variable "+valx_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"
val_w_tb = "variable "+valw_sequence_string[:-1]+": std_logic_vector("+str(bits_input)+"-1 downto 0); --signal \n"

sw_tb

val_w

x

"""# Sum"""

x_sequence_string[:-1]

sw_sequence_string[:-1]

#SIGNALS <= INPUTS
sxr = []
swr = []
i = 0

while True:
  if (i < num_inputs):
    sxr.append("sx"+str(i+1)+"<=x"+str(i+1)+";\n")
    swr.append("sw"+str(i+1)+"<=w"+str(i+1)+";\n")
    i= i+1
  else:
    i= 0
    break

swr

#SOMATÓRIO
sum_all = []
while True:
  if (i == 0):
    sum_all.append("			sum_all <= std_logic_vector((unsigned(sx"+str(i+1)+")*unsigned(sw"+str(i+1)+"))+")
    i= i+1
  else:
    if (i < num_inputs-1):
      sum_all.append("(unsigned(sx"+str(i+1)+")*unsigned(sw"+str(i+1)+"))+")
      i= i+1
    else:
      sum_all.append("(unsigned(sx"+str(i+1)+")*unsigned(sw"+str(i+1)+"))+unsigned(sbias));")
      i= 0
      break

sxr_string = ' '.join(map(str, sxr)) 
swr_string = ' '.join(map(str, swr)) 
sum_all_string = ' '.join(map(str, sum_all)) 
# w_string

swr

swr_string

sum_text = (
'''LIBRARY ieee;
USE ieee.std_logic_1164.all;
use ieee.std_logic_unsigned.all; 
use ieee.numeric_std.all;
use ieee.math_real.all;
use work.STD_DT.ALL;'''
"\n"
"entity sum_python_"+str(num_inputs)+" is \n"
'--generic (input_bit:integer:=8; output_bit:integer:=8;	 n_input:integer:=3); \n'
'port( clk, reset, we: in std_logic; \n'''
'       '+x+''
'       '+w+''

'		bias: in std_logic_vector('+str(bits)+'-1 downto 0) ; -- offset \n'

'		pronto: out std_logic; --done flag   \n'
'		output: out std_logic_vector('+str(bits)+'-1 downto 0) --output signal result \n'
");\n" 
'end entity;\n' 
'\n'
"architecture behavior of sum_python_"+str(num_inputs)+" is\n"
'	signal sum_all : std_logic_vector(('+str(2*bits)+')-1 downto 0); \n'
'   '+sx+''
'   '+sw+''
'	signal sbias: std_logic_vector('+str(bits)+'-1 downto 0); \n'
	 '\n'
'begin \n'
' '+sxr_string+''
' '+swr_string+''
' sbias<= bias; \n'
'\n'
'process(reset, clk, we) \n'
'begin \n'
"   if(reset = '1') then \n"
" 		sum_all<= (OTHERS => '0');\n"
"			pronto <= '0';\n"
'\n'
'	else \n'
"		if(clk'event and clk = '1') then --se tem evento de clock \n"
"		if(we = '0') then --write enable =1  \n"
''+sum_all_string+'\n'

"      if (sum_all > 255) then \n"
"				output <= std_logic_vector(to_unsigned(255, output'length)); \n"
"			elsif (sum_all < 0) then \n"
"				output <= std_logic_vector(to_unsigned(0, output'length)); \n"
"			else \n"
"				output<= sum_all(bits-1 downto 0); \n"
"			end if; \n"
"			pronto <= '1'; \n"
'		end if; \n'
'	end if; \n'
'	end if; \n'
'end process; \n'
'\n'
'end behavior; \n'

'')

text_file = open("sum_python_"+str(num_inputs)+".txt", "w")
text_file.write(sum_text)
text_file.close()

text_file = open("sum_python_"+str(num_inputs)+".vhd", "w")
text_file.write(sum_text)
text_file.close()

"""# Top"""

top_text = (
'''library ieee;
use ieee.numeric_std.all;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use ieee.std_logic_1164.all;
use work.STD_DT.ALL;

'''
"entity top_no_comp_python_"+str(num_inputs)+" is \n"
'''port( clk, reset, we: in std_logic; \n'''
''+x+''
''+w+''
''' bias: in std_logic_vector(bits-1 downto 0) ; -- offset

	datain: in std_logic_vector(bits-1 downto 0);-- for writing in RAM
	
	y: out std_logic_vector(bits-1 downto 0); --output signal result
	
	sum_result_out,RAM_out: out std_logic_vector((bits)-1 downto 0);
	spronto_sum_out: out std_logic;
	pronto_geral: out std_logic
	
); 
end entity; 

'''
"architecture behavior of top_no_comp_python_"+str(num_inputs)+" is \n"'''
--COMPONENTS	

'''"component sum_python_"+str(num_inputs)+" is "'''
port ( clk, reset, we: in std_logic;''' 
'\n		'+x+''
'\n		'+w+''

		'''bias: in std_logic_vector(8-1 downto 0) ; -- offset 
		pronto: out std_logic; --done flag   
		output: out std_logic_vector(8-1 downto 0)
		); --output signal result
END component;

component mem is
port (RST: in std_logic;
		CLK: in std_logic;
		we: in std_logic; --write enable
		address: in std_logic_vector(bits-1 downto 0);
		datain: in std_logic_vector(bits-1 downto 0);
		dataout: out std_logic_vector(bits-1 downto 0));
END component;
'''
'''component registrador is
port (clk, carga : IN STD_LOGIC;
	  d : IN STD_LOGIC_VECTOR(bits-1 DOWNTO 0);
	  q : OUT STD_LOGIC_VECTOR(bits-1 DOWNTO 0));
END component; --clk, carga, d, q'''
'''
--SIGNALS
	signal sum_result, RAM_output, mem_address, out_reg_sum: std_logic_vector((bits)-1 downto 0);
	signal mult_result, div_result, out_reg_div: std_logic_vector((bits*2)-1 downto 0);
	signal spronto_sum: std_logic; --spronto não está sendo lido por enquanto

	--LOGIC BEGIN
begin'''
'''
--PARA ALTERAR O QUE É ESCRITO NO ENDEREÇO PARA LEITURA OU ESCRITA DA MEMÓRIA
process (mem_address, sum_result, bias, we)
begin
	if (we = '1') then
		mem_address <= bias; --NA ESCRITA O ENDEREÇO NÃO VEM DO CÁLCULO DA SOMA_PONDERADA E SIM DO ARQUIVO_TEXTO
	else
		mem_address <= sum_result; --já na leitura de dados de entrada xi e wi, o endereço para cálculo sigmoid vem da soma_ponderada
	end if;
end process;  \n
'''
"sum_all: sum_python_"+str(num_inputs)+" PORT MAP (clk,reset,we,"+x_w_sequence_string+"bias,spronto_sum,sum_result);	--clk,reset,we,inputs,weights,bias,output \n"
"reg_sum: registrador PORT MAP (clk,spronto_sum,sum_result,out_reg_sum);	--clk, carga, d, q \n"
'''
memory: mem PORT MAP (reset,clk,we,mem_address,datain,RAM_output);	--rst,clk,we,address,datain,dataout

--sinais analise
spronto_sum_out<= spronto_sum;
sum_result_out<= sum_result;
RAM_out<= RAM_output;

---------WILL BE USED WHEN SIGNED---
	process (sum_result,reset,clk,datain,RAM_output,mult_result,div_result)
	begin
	
	if(reset = '1') then	
		pronto_geral<= '0';
		
	elsif clk'event and clk = '1' then
		if spronto_sum = '1' then
			if (((sum_result> std_logic_vector(to_unsigned(135,bits))) or (sum_result< std_logic_vector(to_unsigned(121,bits))))) then --caso (sum_result > 7), y= sum_result
				
				if(sum_result> std_logic_vector(to_unsigned(135,bits))) then
					y<= std_logic_vector(signed(sum_result));
					pronto_geral<= '1', '0' after clk_period/2;
					
				else
					y<= zeros;
					pronto_geral<= '1', '0' after clk_period/2;
					
				end if;
				
			else --when (121 <= sum_result <= 135)	
						
						--y<= std_logic_vector(unsigned(div_result(bits-1 downto 0)));
						y<= RAM_output;
						pronto_geral<= '1', '0' after clk_period/2;
				
			end if; -- end if sum_result
		end if; -- end if spronto_sum
	end if; --end if reset
	end process;

end behavior;



''')

text_file = open("top_no_comp_python_"+str(num_inputs)+".txt", "w")
text_file.write(top_text)
text_file.close()

text_file = open("top_no_comp_python_"+str(num_inputs)+".vhd", "w")
text_file.write(top_text)
text_file.close()

"""# Testbench"""

x_sequence_string

#Xi Wi String Sequence
read_x_sequence = []
read_w_sequence = []
xr_tb_sequence = []
wr_tb_sequence = []

while True:
  if (i < num_inputs):
    read_x_sequence.append("          read(read_col_from_input_buf, val_x"+str(i+1)+"); \n "
    "           read(read_col_from_input_buf, val_SPACE);\n\n")
    read_w_sequence.append("          read(read_col_from_input_buf, val_w"+str(i+1)+"); \n "
    "           read(read_col_from_input_buf, val_SPACE);\n\n")
    xr_tb_sequence.append("				x"+str(i+1)+"<= std_logic_vector(val_x"+str(i+1)+");\n")
    wr_tb_sequence.append("				w"+str(i+1)+"<= std_logic_vector(val_w"+str(i+1)+");\n")
    
    i= i+1
  else:
    read_x_sequence_string = ' '.join(map(str, (read_x_sequence))) 
    read_w_sequence_string = ' '.join(map(str, (read_w_sequence))) 
    xr_tb_sequence_string = ' '.join(map(str, (xr_tb_sequence))) 
    wr_tb_sequence_string = ' '.join(map(str, (wr_tb_sequence))) 
    i= 0
    break

top_tb_text = (
"library ieee;  \n"
"use ieee.std_logic_1164.all;  \n"
"use ieee.numeric_std.all;  \n"
"use std.textio.all;  \n"
"use ieee.std_logic_textio.all;	-- para tratamento de arquivos e texto -> file_open...  \n"
"use work.STD_DT.all;  \n"
"  \n"
"entity top_tb_python_"+str(num_inputs)+" is  \n"
"end top_tb_python_"+str(num_inputs)+";  \n"
"\n"
"architecture tb of top_tb_python_"+str(num_inputs)+" is   \n"
"	signal clk, reset,we,spronto_sum_out: std_logic;  \n"
'   '+sx_tb+''
'   '+sw_tb+''
'''   signal bias,datain,y: std_logic_vector(bits-1 downto 0);
	signal sum_result_out,RAM_out: std_logic_vector((bits)-1 downto 0);
	constant sigmoid_read_time: time := 16*clk_period;
	signal pronto_geral: std_logic;

begin
	--conectando os sinais do test bench aos sinais do contador
	'''"UUT: entity work.top_no_comp_python_"+str(num_inputs)+" port map \n"
		 "(clk=>clk,reset=>reset,we=>we,"+xw_map_tb_sequence_string+"bias=>bias,datain=>datain,y=>y,sum_result_out=>sum_result_out,RAM_out=>RAM_out,spronto_sum_out=>spronto_sum_out,pronto_geral=>pronto_geral);--RAM_out,mult_result_out, div_result		\n"
"\n"'''
   reset <= '1', '0' after clk_period/2, '1' after (sigmoid_read_time+clk_period), '0' after (sigmoid_read_time+clk_period+clk_period);
	we <= '1', '0' after sigmoid_read_time;
		
	--processo gerador de clock
	clk_gen : process
	--constant period: time := 20 ns;
	begin
		clk <= '0';
		wait for clk_period/2; -- 50% do periodo pra cada nivel
		clk <= '1';
		wait for clk_period/2;
	end process;
	

	-- processo para leitura das entradas e escrita das sai­das
	file_io: process
		
		--SIGNALS AND VARIABLES
		variable read_col_from_input_buf: line; -- buffers de entrada e sai­da
		file input_buf: text; --text is keyword ->??
		
		variable read_col_from_sigmoid_buf: line;
		file sigmoid_buf: text; --text is keyword -->??
		
		variable write_col_to_output_buf: line;
		file output_buf: text; --text is keyword -->??\n''' 
"\n"
"		variable val_address, val_datain: std_logic_vector(bits-1 downto 0);\n"
"     "+val_x_tb+"\n"
"     "+val_w_tb+"\n"
'''     variable val_bias: std_logic_vector(bits-1 downto 0);
    variable val_SPACE: character; -- espacos da leitura de cada linha de entrada
		
		begin
			--arquivo de entrada do tb
			file_open(input_buf, '''r'''"C:\Users\luisa\Documents\Materias\UFSC\20201\Lab_EBD_ECL\Perpeptron\NN_Neuron_unsigned_no_components_generic_inputs_python\text_files\c__data_df_inputs_bin.txt"'''''',  read_mode);
			
			--arquivo de enderecos e valores da sigmoide
			file_open(sigmoid_buf, '''r'''"C:\Users\luisa\Documents\Materias\UFSC\20201\Lab_EBD_ECL\Perpeptron\NN_Neuron_unsigned_no_components_generic_inputs_python\text_files\c__data_df_sigmoid_bin.txt"'''''',  read_mode); 

			--arquivo de saí­da do tb
			file_open(output_buf, '''r'''"C:\Users\luisa\Documents\Materias\UFSC\20201\Lab_EBD_ECL\Perpeptron\NN_Neuron_unsigned_no_components_generic_inputs_python\text_files\saidas_tb.txt"'''''',  write_mode);
			wait until reset = '0'; -- espera reset desligar
      
      --LEITURA SIGMOIDE
			while not endfile (sigmoid_buf) loop
				readline(sigmoid_buf, read_col_from_sigmoid_buf); --lÃª_linha buffer primeira linha -> escreve na variÃ¡vel
				
				read(read_col_from_sigmoid_buf, val_address); -- pega endereço
				read(read_col_from_sigmoid_buf, val_SPACE);           -- read in the space character
				read(read_col_from_sigmoid_buf, val_datain); -- pega valor da sigmoide
				
				-- Pass the read values to signals
				bias<= std_logic_vector(val_address);
				datain<= std_logic_vector(val_datain);
				
			wait for clk_period;
			end loop;
						
			--LEITURA ENTRADA E ESCRITA NO ARQUIVO DE SAÍDA----
			while not endfile(input_buf) loop --enquanto arquivo nÃ£o terminar de ler
			
				readline(input_buf, read_col_from_input_buf); --le_linha buffer primeira linha -> escreve na variavel\n'''

''+read_x_sequence_string+''
''+read_w_sequence_string+''

'''				read(read_col_from_input_buf, val_bias); --pega primeiros n bits

			-- Pass the read values to signals\n'''
''+xr_tb_sequence_string+''
''+wr_tb_sequence_string+''
'''				bias<= std_logic_vector(val_bias);
				

			wait for (2*clk_period);

				write(write_col_to_output_buf, y); --Pega valor da saida e associa ao sinal
				writeline(output_buf, write_col_to_output_buf); --Escreve valor da saida (do sinal) no arquivo de texto
			end loop; --END: LEITURA ENTRADA E ESCRITA NO ARQUIVO DE SAÍDA----
					
		write(write_col_to_output_buf, string'("SIMULACAO CONCLUIDA")); --para confirmar que saiu do loop e está tudo ok
		writeline(output_buf, write_col_to_output_buf);
		file_close(input_buf); --fecha leitura arquivo INPUTS
		file_close(sigmoid_buf); --fecha leitura arquivo SIGMOIDE
		file_close(output_buf); --fecha arquivo OUTPUTS
		
	wait; --sem ele nd funciona; -->Pq??
	end process;
end tb;

''')

text_file = open("top_tb_python_"+str(num_inputs)+".txt", "w")
text_file.write(top_tb_text)
text_file.close()

text_file = open("top_tb_python_"+str(num_inputs)+".vhd", "w")
text_file.write(top_tb_text)
text_file.close()